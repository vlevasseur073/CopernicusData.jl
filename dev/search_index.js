var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-notes","page":"Release Notes","title":"Release notes","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Version:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"using CopernicusData # hide\npkgversion(CopernicusData) # hide","category":"page"},{"location":"release_notes/#Current-release-overview","page":"Release Notes","title":"Current release overview","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Export YAXTrees.to_zarr function","category":"page"},{"location":"release_notes/#History","page":"Release Notes","title":"History","text":"","category":"section"},{"location":"release_notes/#v0.2.0","page":"Release Notes","title":"v0.2.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Add YAXTree filtering feature based on variable selection. See YAXTrees.select_vars and YAXTrees.exclude_vars\nAdd YAXTree isomorphic check. Two YAXTree are isomorphic if they have the exact same tree structure and if the data contained in equivalent node","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"is the same type (YAXArrays.YAXArray or YAXArrays.Datasets.Dataset) and have the same variables and same dimensions.  It does not compare the content of the arrays itself. See YAXTrees.isomorphic","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Improve documentation. Use Makie.jl for visualization","category":"page"},{"location":"release_notes/#v0.1.0","page":"Release Notes","title":"v0.1.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Implementation of data structure to hold the new CopernicusData zarr Sentinels products from the Copernicus mission\nYAXTrees module implements f hierarchical tree structure of YAXArrays or Datasets from YAXArrays.jl package\nImplementation of a light orchestrator to run any kind of processing module from a input payload file: \nread the inputs products\nrun the provided workflows\nstore the output products","category":"page"},{"location":"release_notes/#Status-of-the-package","page":"Release Notes","title":"Status of the package","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This is a beta release","category":"page"},{"location":"release_notes/#Known-problems-or-limitations","page":"Release Notes","title":"Known problems or limitations","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Reading zipped zarr is not fully handled. Feature to be requested to Zarr.jl package https://github.com/JuliaIO/Zarr.jl/issues/189. The current Zarrl.ZipStore handles files on the local filesystem not yet files on a cloud storage.\nBasic interpolations are implementations. To be improved in the future releases, in connection with upcoming improvements of YAXArrays.jl\nHandling the legacy SAFE format for few missions to come. (Likely Sentinle-3 at first)","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#CopernicusData.get_AWS_config","page":"API Reference","title":"CopernicusData.get_AWS_config","text":"function get_AWS_config(profile::String=\"default\")\n\nGenerate and AWS config given a profile name. To get the credentials, the function follows the priority as: 1- get aws config and credentials file as INI files in default path: ~/.aws 2- use environement varialbes (AWSSECRETACCESSKEY, AWSACCESSKEYID, ...)\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.s3_get_object-Tuple{String}","page":"API Reference","title":"CopernicusData.s3_get_object","text":"function s3getobject(full_path::String)     Get and object from a S3 bucket given its full path (s3://....)\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.EOProducts.eoproduct_dataset-Tuple{String}","page":"API Reference","title":"CopernicusData.EOProducts.eoproduct_dataset","text":"eoproduct_dataset(path::String)::Dict{String, Dataset}\n\nOpen a Copernicus product returns a Dict{String,Dataset} containing all the Variables stored in the product\n\nExamples\n\njulia> d = open_eoproduct(\"S3SLSLST_20191227T124111_0179_A109_T921.zarr\")\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.EOProducts.open_eoproduct-Tuple{String}","page":"API Reference","title":"CopernicusData.EOProducts.open_eoproduct","text":"open_eoproduct(path::String)\n\nOpen a Copernicus Zarr product returns a Dict{String,ZArray} containing all the Variables stored in the product\n\nExamples\n\njulia> d = open_eoproduct(\"S3SLSLST_20191227T124111_0179_A109_T921.zarr\")\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.YAXTree","page":"API Reference","title":"CopernicusData.YAXTrees.YAXTree","text":"YAXTree\n\nA tree data structure for representing hierarchical data with optional data arrays.\n\nFields\n\nname::String: The name of the node\npath::String: The full path to this node in the tree\nproperties::Dict{String, Any}: Additional properties/metadata for the node\nparent::Union{Nothing, YAXTree}: Reference to parent node, or nothing for root\nchildren::Dict{String, YAXTree}: Dictionary of child nodes\ndata::Union{Nothing, YAXArray, YAXArrays.Datasets.Dataset}: Optional data associated with the node\n\n\n\n\n\n","category":"type"},{"location":"api/#CopernicusData.YAXTrees.YAXTree-Tuple{String}","page":"API Reference","title":"CopernicusData.YAXTrees.YAXTree","text":"YAXTree(name::String; parent=nothing, data=nothing)\n\nCreate a new YAXTree node with the specified name and optional parent and data.\n\nArguments\n\nname::String: The name of the node\nparent=nothing: Optional parent node\ndata=nothing: Optional data to associate with the node\n\nReturns\n\nYAXTree: A new tree node\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.YAXTree-Tuple{Zarr.ZGroup}","page":"API Reference","title":"CopernicusData.YAXTrees.YAXTree","text":"YAXTree(zgroup::ZGroup)\n\nCreate a YAXTree from a Zarr group structure.\n\nArguments\n\nzgroup::ZGroup: The Zarr group to convert to a tree\n\nReturns\n\nYAXTree: A new tree representing the Zarr group hierarchy\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.YAXTree-Tuple{}","page":"API Reference","title":"CopernicusData.YAXTrees.YAXTree","text":"YAXTree()\n\nCreate a new empty YAXTree with default root node.\n\nReturns\n\nYAXTree: A new tree with root node named \"root\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{YAXTree, String}","page":"API Reference","title":"Base.getindex","text":"getindex(tree::YAXTree, path::String)::YAXTree\n\nAccess a node in the tree using a path string, where path components are separated by \"/\".\n\nArguments\n\ntree::YAXTree: The tree to search in\npath::String: Path to the desired node, components separated by \"/\"\n\nReturns\n\nYAXTree: The node at the specified path\n\nThrows\n\nKeyError: If any component of the path does not exist in the tree\n\nExamples\n\nnode = tree[\"data/temperature/daily\"]  # Get node at path \"data/temperature/daily\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{YAXTree, CopernicusData.YAXTrees.YAXTreeIteratorState}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(tree::YAXTree, state::YAXTreeIteratorState)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{YAXTree}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(tree::YAXTree)\n\nCreates an iterator that traverses the YAXTree in a depth-first, pre-order fashion.\n\nThis iterator yields each node in the tree, ensuring that no node is visited twice, even if children share the same name. The path of each node is used as a unique identifier.\n\nExamples\n\n# Assuming a YAXTree 'my_tree' is defined:\nfor node in my_tree\n    println(node.name, \" at path \", node.path)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.add_children!","page":"API Reference","title":"CopernicusData.YAXTrees.add_children!","text":"add_children!(tree::YAXTree, name::Union{String,Symbol}, data::Union{Nothing, YAXArray, YAXArrays.Datasets.Dataset}=nothing)\n\nAdd a child node to the tree with the given name and optional data.\n\nArguments\n\ntree::YAXTree: The parent tree node\nname::Union{String,Symbol}: Name of the new child node (must not contain '/')\ndata::Union{Nothing, YAXArray, YAXArrays.Datasets.Dataset}=nothing: Optional data to associate with the node\n\nThrows\n\nArgumentError: If the name contains '/' or if a child with the same name already exists\n\nExamples\n\nadd_children!(tree, \"temperature\", temperature_data)\nadd_children!(tree, :pressure)  # Add empty node\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.YAXTrees.add_children_full_path!","page":"API Reference","title":"CopernicusData.YAXTrees.add_children_full_path!","text":"add_children_full_path!(tree::YAXTree, path::String, data::Union{Nothing, YAXArray, YAXArrays.Datasets.Dataset}=nothing)\n\nAdd nodes to the tree following a full path, creating intermediate nodes as needed.\n\nArguments\n\ntree::YAXTree: The root tree node\npath::String: Full path of nodes to create, components separated by \"/\"\ndata::Union{Nothing, YAXArray, YAXArrays.Datasets.Dataset}=nothing: Optional data to associate with the leaf node\n\nExamples\n\n# Creates nodes \"data\", \"temperature\", and \"daily\" if they don't exist\nadd_children_full_path!(tree, \"data/temperature/daily\", temp_data)\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.YAXTrees.copy_subset-Union{Tuple{T}, Tuple{YAXArrays.Datasets.Dataset, Vector{T}}} where T<:Union{String, Symbol}","page":"API Reference","title":"CopernicusData.YAXTrees.copy_subset","text":"copy_subset(x::YAXArrays.Datasets.Dataset, varnames::Vector{T}; error::Bool=false, verbose::Bool=true)::YAXArrays.Datasets.Dataset\n\nCreate a copy of a dataset containing only the specified variables.\n\nArguments\n\nx::YAXArrays.Datasets.Dataset: The source dataset to copy from\nvarnames::Vector{T}: List of variable names to include in the copy, where T is either String or Symbol\n\nKeyword Arguments\n\nerror::Bool=false: If true, raises an error if any variable in varnames is not present in the dataset\nverbose::Bool=true: If true, logs warnings for variables that are not found in the dataset\n\nReturns\n\nYAXArrays.Datasets.Dataset: A new dataset containing only the specified variables\n\nExamples\n\nnew_dataset = copy_subset(original_dataset, [\"temperature\", \"pressure\"])\n# or\nnew_dataset = copy_subset(original_dataset, [:temperature, :pressure])\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.exclude_vars-Union{Tuple{T}, Tuple{YAXTree, Vector{T}}} where T<:Union{String, Symbol}","page":"API Reference","title":"CopernicusData.YAXTrees.exclude_vars","text":"exclude_vars(tree::YAXTree, varnames::Vector{T}; drop::Bool=false)::YAXTree where T <: Union{String,Symbol}\n\nCreate a new YAXTree excluding the specified variables.\n\nArguments\n\ntree::YAXTree: The source tree\nvarnames::Vector{String} or Vector{Symbol}: List of variable names to exclude\n\nKeyword Arguments\n\ndrop::Bool=false: If true, remove nodes that do not contain any of the specified variables.\n\nIf false, keep nodes even with empty dataset, to preserve the tree structure\n\nReturns\n\nYAXTree: A new tree excluding the specified variables\n\nExamples\n\nnew_tree = exclude_vars(tree, [\"temperature\", \"pressure\"])\n# or\nnew_tree = exclude_vars(tree, [:temperature, :pressure])\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.isomorphic-Tuple{YAXTree, YAXTree}","page":"API Reference","title":"CopernicusData.YAXTrees.isomorphic","text":"isomorphic(tree1::YAXTree, tree2::YAXTree)::Bool\n\nCheck if two YAXTree structures are isomorphic. Two YAXTree are isomorphic if they have the exact same tree structure and if the data contained in equivalent node is the same type (YAXArrays.YAXArray or YAXArrays.Datasets.Dataset) and have the same variables and same dimensions. \n\nArguments\n\ntree1::YAXTree: The first tree to compare\ntree2::YAXTree: The second tree to compare\n\nReturns\n\nBool: true if the trees are isomorphic, false otherwise\n\nExamples\n\nisomorphic(tree1, tree2)  # Returns true if both trees have the same structure and data\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.open_datatree","page":"API Reference","title":"CopernicusData.YAXTrees.open_datatree","text":"open_datatree(path::String, driver::Union{Nothing,Symbol}=nothing; name::String=\"root\")::YAXTree\n\nOpen a data product and create a YAXTree representation of its structure. The driver is automatically detected from the file extension or can be specified manually.\n\nArguments\n\npath::String: Path to the data product, can be local file/directory or S3 URL\ndriver::Union{Nothing,Symbol}=nothing: Optional driver specification. Supported values:\n:zarr: For Zarr format files/directories\n:sen3: For Sentinel-3 SEN3 format\n:json: For JSON files\nname::String=\"root\": Name for the root node of the tree\n\nReturns\n\nYAXTree: A tree representation of the data product structure\n\nThrows\n\nException: If the file doesn't exist or the driver is not supported\n\nExamples\n\n# Auto-detect driver from extension\ndt = open_datatree(\"S03SLSLST_20191227T124111_0179_A109_T921.zarr\")\n\n# Explicitly specify driver\ndt = open_datatree(\"data.SEN3\", :sen3)\n\n# Open from S3\ndt = open_datatree(\"s3://bucket/path/data.zarr\")\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.YAXTrees.open_zarr_datatree-Tuple{String}","page":"API Reference","title":"CopernicusData.YAXTrees.open_zarr_datatree","text":"open_zarr_datatree(path::String; name::String=\"root\", archive::Bool=false)::YAXTree\n\nOpen a Zarr format file/directory and create a YAXTree representation. Supports both local and S3 paths, and optionally handles ZIP archives containing Zarr data.\n\nArguments\n\npath::String: Path to Zarr file/directory, can be local or S3 URL\nname::String=\"root\": Name for the root node of the tree\narchive::Bool=false: Set to true if path points to a ZIP archive containing Zarr data\n\nReturns\n\nYAXTree: A tree representation of the Zarr data structure\n\nThrows\n\nException: If the file/directory doesn't exist\n\nExamples\n\n# Open local Zarr directory\ntree = open_zarr_datatree(\"data.zarr\")\n\n# Open Zarr from ZIP archive\ntree = open_zarr_datatree(\"data.zarr.zip\", archive=true)\n\n# Open from S3\ntree = open_zarr_datatree(\"s3://bucket/data.zarr\")\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.path_exists-Tuple{YAXTree, String}","page":"API Reference","title":"CopernicusData.YAXTrees.path_exists","text":"path_exists(tree::YAXTree, path::String)::Bool\n\nCheck if a path exists in the tree.\n\nArguments\n\ntree::YAXTree: The tree to search in\npath::String: Path to check, components separated by \"/\"\n\nReturns\n\nBool: true if path exists, false otherwise\n\nExamples\n\nif is_path_exists(tree, \"data/temperature/daily\")\n    node = tree[\"data/temperature/daily\"]\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.pwhere-Tuple{YAXArrays.Cubes.YAXArray{Bool, N, A} where {N, A<:AbstractArray{Bool, N}}, Any, Any, Any}","page":"API Reference","title":"CopernicusData.YAXTrees.pwhere","text":"pwhere(cond::YAXArray{Bool}, val1, val2, chunks)\n\nParallel version of where that operates on chunked arrays for improved performance with large datasets.\n\nArguments\n\ncond::YAXArray{Bool}: Boolean condition array\nval1: Value to select when condition is true\nval2: Value to select when condition is false\nchunks: Chunk specification for parallel processing\n\nReturns\n\nYAXArray: Chunked array where each element is val1 where cond is true, val2 otherwise\n\nExamples\n\n# Process large array in parallel chunks\nresult = pwhere(large_condition, a, b, (1000, 1000))\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.select_vars-Union{Tuple{T}, Tuple{YAXTree, Vector{T}}} where T<:Union{String, Symbol}","page":"API Reference","title":"CopernicusData.YAXTrees.select_vars","text":"select_vars(tree::YAXTree, varnames::Vector{T})::YAXTree where T <: Union{String,Symbol}\n\nCreate a new YAXTree containing only the specified variables.\n\nArguments\n\ntree::YAXTree: The source tree\nvarnames::Vector{String} or Vector{Symbol}: List of variable names to select\n\nKeyword Arguments\n\nexclusive::Bool=false: If true, only include the specified variables and remove all others. \n\nIn the case when a node has only variable different from the specified ones, the node is removed. If false, keep only the specified variables from nodes which contains all or some of them, but do not affect nodes that do not contain any of the specified variables.\n\nReturns\n\nYAXTree: A new tree containing only the selected variables\n\nExamples\n\nnew_tree = select_vars(tree, [\"temperature\", \"pressure\"])\n# or\nnew_tree = select_vars(tree, [:temperature, :pressure])\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.show_tree","page":"API Reference","title":"CopernicusData.YAXTrees.show_tree","text":"show_tree(io::IO, tree::YAXTree, prefix::String = \"\"; details::Bool = false)\n\nDisplay a tree structure to an IO stream in a hierarchical format with optional detailed information.\n\nArguments\n\nio::IO: The IO stream to write to\ntree::YAXTree: The tree to display\nprefix::String=\"\": Prefix string for indentation\ndetails::Bool=false: Whether to show detailed information about data nodes\n\nExamples\n\nbuf = IOBuffer()\nshow_tree(buf, my_tree, details=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.YAXTrees.show_tree-2","page":"API Reference","title":"CopernicusData.YAXTrees.show_tree","text":"show_tree(tree::YAXTree, prefix::String = \"\"; details::Bool=false)\n\nDisplay a tree structure in a hierarchical format with optional detailed information.\n\nArguments\n\ntree::YAXTree: The tree to display\nprefix::String=\"\": Prefix string for indentation\ndetails::Bool=false: Whether to show detailed information about data nodes\n\nExamples\n\nshow_tree(my_tree)  # Basic display\nshow_tree(my_tree, details=true)  # Show with data details\n\n\n\n\n\n","category":"function"},{"location":"api/#CopernicusData.YAXTrees.where-Tuple{YAXArrays.Cubes.YAXArray{Bool, N, A} where {N, A<:AbstractArray{Bool, N}}, Any, Any}","page":"API Reference","title":"CopernicusData.YAXTrees.where","text":"where(cond::YAXArray{Bool}, val1, val2)::YAXArray\n\nElement-wise conditional selection between two values based on a boolean condition array.\n\nArguments\n\ncond::YAXArray{Bool}: Boolean condition array\nval1: Value to select when condition is true\nval2: Value to select when condition is false\n\nReturns\n\nYAXArray: Array where each element is val1 where cond is true, val2 otherwise\n\nExamples\n\n# Create array with values from a where condition is true, b otherwise\nresult = where(condition_array, a, b)\n\n\n\n\n\n","category":"method"},{"location":"api/#CopernicusData.YAXTrees.@map_over_subtrees-Tuple{Any, Any}","page":"API Reference","title":"CopernicusData.YAXTrees.@map_over_subtrees","text":"macro map_over_subtrees(func, tree)\n\nMap a function func over all the nodes of a YAXTree structure which contains a YAXArray or YAXArrays.Datasets.Dataset\n\nExamples\n\n# Assuming a YAXTree 'my_tree' is defined:\nf(tree::YAXTree) = @show tree.name\nYAXTrees.@map_over_subtrees f my_tree\n\n\n\n\n\n","category":"macro"},{"location":"getting_started/#YAXTrees","page":"Getting Started","title":"YAXTrees","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The YAXTree module provides a hierarchical data structure for working with nested data arrays and datasets. It's particularly useful for handling complex data structures like Zarr groups or JSON hierarchies.","category":"page"},{"location":"getting_started/#Creating-Trees","page":"Getting Started","title":"Creating Trees","text":"","category":"section"},{"location":"getting_started/#Basic-Tree-Creation","page":"Getting Started","title":"Basic Tree Creation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create an empty root node\nroot = YAXTree()\n\n# Create a node with a specific name\nnode = YAXTree(\"mynode\")\n\n# Create a node with data\nusing YAXArrays\ndata = YAXArray((Dim{:rows}(1:10),), collect(1:10))\ndata_node = YAXTree(\"data_node\", data=data)","category":"page"},{"location":"getting_started/#Adding-Children","page":"Getting Started","title":"Adding Children","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Add children to a tree\nroot = YAXTree()\nadd_children!(root, \"child1\")  # Add empty child\nadd_children!(root, \"child2\", data)  # Add child with data\n\n# Add nested children using a path\nadd_children_full_path!(root, \"path/to/deep/child\", data)","category":"page"},{"location":"getting_started/#Tree-Navigation-and-Access","page":"Getting Started","title":"Tree Navigation and Access","text":"","category":"section"},{"location":"getting_started/#Accessing-Nodes","page":"Getting Started","title":"Accessing Nodes","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Access children using property syntax\nchild1 = root.child1\ngrandchild = root.child1.grandchild\n\n# Access using string paths\nnode = root[\"path/to/node\"]\n\n# Check if a path exists\nif path_exists(root, \"path/to/node\")\n    # Do something\nend","category":"page"},{"location":"getting_started/#Iterating-Over-Trees","page":"Getting Started","title":"Iterating Over Trees","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Iterate over all nodes in the tree (depth-first)\nfor node in root\n    println(node.name)\nend\n\n# Using the map_over_subtrees macro\nfunction process_node(tree::YAXTree)\n    if !isnothing(tree.data)\n        # Process data\n    end\nend\n\nYAXTrees.@map_over_subtrees process_node root","category":"page"},{"location":"getting_started/#Working-with-Data","page":"Getting Started","title":"Working with Data","text":"","category":"section"},{"location":"getting_started/#Data-Selection-and-Filtering","page":"Getting Started","title":"Data Selection and Filtering","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Filter data based on conditions\nmask = YAXArray((rows, time), rand(Bool, (100, 36)))\ntemperature = YAXArray((rows, time), rand(-40:40, (100, 36)))\n\n# Replace values where mask is true with missing\nmasked_data = where(mask, temperature, missing)\n\n# Parallel processing for large arrays\nchunked_result = pwhere(mask, temperature, -1, (50, 50))","category":"page"},{"location":"getting_started/#File-I/O-Operations","page":"Getting Started","title":"File I/O Operations","text":"","category":"section"},{"location":"getting_started/#Opening-Data-Trees","page":"Getting Started","title":"Opening Data Trees","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Open from Zarr format\ntree = open_datatree(\"data.zarr\")\n\n# Open from zipped Zarr\ntree = open_datatree(\"data.zarr.zip\")\n\n# Open from JSON\ntree = open_datatree(\"data.json\", :json)\n\n# Open from S3\ntree = open_datatree(\"s3://bucket/data.zarr\")","category":"page"},{"location":"getting_started/#Writing-to-Zarr","page":"Getting Started","title":"Writing to Zarr","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Save tree to Zarr format\nto_zarr(tree, \"output.zarr\")","category":"page"},{"location":"getting_started/#Visualization","page":"Getting Started","title":"Visualization","text":"","category":"section"},{"location":"getting_started/#Display-Tree-Structure","page":"Getting Started","title":"Display Tree Structure","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic tree display\nshow_tree(tree)\n\n# Display with detailed information\nshow_tree(tree, details=true)\n\n# Custom display with prefix\nshow_tree(tree, \"  \", details=true)","category":"page"},{"location":"getting_started/#Isomorphism-check","page":"Getting Started","title":"Isomorphism check","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The YAXTrees.isomorphic function returns a boolean whether 2 trees are isomorphic or not. Two YAXTree are isomorphic if they have the exact same tree structure and if the data contained in equivalent node is the same type (YAXArrays.YAXArray or YAXArrays.Datasets.Dataset) and have the same variables and same dimensions. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"isomorphic(tree1, tree2)  # Returns true if both trees have the same structure and data","category":"page"},{"location":"getting_started/#Advanced-Features","page":"Getting Started","title":"Advanced Features","text":"","category":"section"},{"location":"getting_started/#Copying-and-Subsetting","page":"Getting Started","title":"Copying and Subsetting","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The select_vars function provides flexible ways to select and copy parts of your data tree:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic variable selection\nselected_tree = select_vars(tree, [\"temperature\", \"pressure\"])  # using strings\nselected_tree = select_vars(tree, [:temperature, :pressure])    # using symbols\n\n# Non-exclusive mode (default)\n# - Keeps nodes that have any of the specified variables\n# - Preserves nodes without any of the specified variables\ntree1 = select_vars(root, [\"temperature\", \"pressure\"])\n\n# Exclusive mode\n# Only keeps nodes that have the specified variables\n# Removes nodes that only have different variables\ntree2 = select_vars(root, [\"temperature\", \"pressure\"], exclusive=true)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Example with different behaviors:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a test tree with different datasets\nroot = YAXTree()\n\n# Dataset with temperature and pressure\nds1 = Dataset(\n    temperature = YAXArray((Dim{:x}(1:3),), [20.0, 21.0, 22.0]),\n    pressure = YAXArray((Dim{:x}(1:3),), [1000.0, 1001.0, 1002.0]),\n    humidity = YAXArray((Dim{:x}(1:3),), [0.6, 0.7, 0.8])\n)\n\n# Dataset with only wind_speed\nds2 = Dataset(\n    wind_speed = YAXArray((Dim{:x}(1:3),), [5.0, 6.0, 7.0])\n)\n\n# Add datasets to tree\nroot.data = ds1\nroot.child = YAXTree(\"child\", data=ds2)\n\n# Non-exclusive selection - keeps both nodes\nselected1 = select_vars(root, [\"temperature\"])\n@assert path_exists(selected1, \"child\") == true  # child node kept\n\n# Exclusive selection - removes child node as it has no selected variables\nselected2 = select_vars(root, [\"temperature\"], exclusive=true)\n@assert path_exists(selected2, \"child\") == false  # child node removed\n\n# Control error handling with datasets\ncopied_ds = copy_subset(dataset, [\"temperature\", \"pressure\"],\n                     error=false,    # Don't error on missing variables\n                     verbose=true)   # Show warning for missing variables\n\n# Remove unwanted variables\nfiltered_tree = exclude_vars(tree, [\"humidity\", \"wind_speed\"])\n\n# Advanced filtering example:\nroot = YAXTree()\n\n# Create datasets with different variables\nds_main = Dataset(\n    temperature = YAXArray((Dim{:x}(1:3),), [20.0, 21.0, 22.0]),\n    pressure = YAXArray((Dim{:x}(1:3),), [1000.0, 1001.0, 1002.0]),\n    humidity = YAXArray((Dim{:x}(1:3),), [0.6, 0.7, 0.8])\n)\n\nds_weather = Dataset(\n    wind_speed = YAXArray((Dim{:x}(1:3),), [5.0, 6.0, 7.0])\n)\n\n# Build tree structure\nroot.data = ds_main                     # Add main dataset to root\nroot.weather = YAXTree(\"weather\", data=ds_weather)  # Add weather node\n\n# Different selection behaviors:\n# 1. Non-exclusive - keeps structure, filters variables where found\nfiltered1 = select_vars(root, [\"temperature\", \"pressure\"])\n@assert haskey(filtered1.children, \"weather\")  # weather node remains\n\n# 2. Exclusive - only keeps nodes containing selected variables\nfiltered2 = select_vars(root, [\"temperature\"], exclusive=true)\n@assert !haskey(filtered2.children, \"weather\")  # weather node removed\n\n# 3. Exclude specific variables\nfiltered3 = exclude_vars(root, [\"humidity\", \"wind_speed\"])\n# Result has temperature and pressure, but not humidity or wind_speed","category":"page"},{"location":"getting_started/#Excluding-Variables-from-Trees","page":"Getting Started","title":"Excluding Variables from Trees","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The exclude_vars function provides a way to remove specific variables from datasets in a tree while preserving the tree structure. This is useful when you want to work with a subset of variables by specifying which ones to remove rather than which ones to keep.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic variable exclusion\nfiltered_tree = exclude_vars(tree, [\"humidity\", \"wind_speed\"])  # using strings\nfiltered_tree = exclude_vars(tree, [:humidity, :wind_speed])    # using symbols","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Key features of exclude_vars:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Tree Structure Preservation: The function maintains the original tree structure, only modifying the dataset contents.\nNested Dataset Handling: Variables are excluded from all datasets in the tree, regardless of their location in the hierarchy.\nVariable Type Support: Works with both String and Symbol variable names.\nNode Cleanup: If all variables are excluded from a dataset, that node's data becomes nothing.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's a comprehensive example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a test tree with nested datasets\nroot = YAXTree()\n\n# Create main dataset with multiple variables\nmain_ds = Dataset(\n    temperature = YAXArray((Dim{:x}(1:3),), [20.0, 21.0, 22.0]),\n    pressure = YAXArray((Dim{:x}(1:3),), [1000.0, 1001.0, 1002.0]),\n    humidity = YAXArray((Dim{:x}(1:3),), [0.6, 0.7, 0.8])\n)\n\n# Create weather dataset with different variables\nweather_ds = Dataset(\n    wind_speed = YAXArray((Dim{:x}(1:3),), [5.0, 6.0, 7.0]),\n    humidity = YAXArray((Dim{:x}(1:3),), [0.5, 0.6, 0.7])\n)\n\n# Build tree structure\nroot.data = main_ds\nroot.weather = YAXTree(\"weather\", data=weather_ds)\n\n# Example 1: Exclude a single variable across all nodes\nfiltered = exclude_vars(root, [\"humidity\"])\n@assert haskey(filtered.data.cubes, :temperature)     # Kept\n@assert haskey(filtered.data.cubes, :pressure)        # Kept\n@assert !haskey(filtered.data.cubes, :humidity)       # Removed\n@assert haskey(filtered.weather.data.cubes, :wind_speed)  # Kept\n@assert !haskey(filtered.weather.data.cubes, :humidity)   # Removed\n\n# Example 2: Exclude multiple variables\nfiltered = exclude_vars(root, [\"humidity\", \"pressure\"])\n@assert haskey(filtered.data.cubes, :temperature)      # Kept\n@assert !haskey(filtered.data.cubes, :pressure)        # Removed\n@assert !haskey(filtered.data.cubes, :humidity)        # Removed\n@assert haskey(filtered.weather.data.cubes, :wind_speed)  # Kept\n\n# Example 3: Exclude all variables from a node\nfiltered = exclude_vars(root, [\"wind_speed\", \"humidity\"])\n@assert haskey(filtered.data.cubes, :temperature)      # Kept\n@assert haskey(filtered.data.cubes, :pressure)         # Kept\n@assert !haskey(filtered.data.cubes, :humidity)        # Removed\n@assert isnothing(filtered.weather.data)               # Node data cleared as all variables excluded","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Common use cases for exclude_vars:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Removing unwanted or redundant variables from a dataset\nCreating a lightweight version of a tree by excluding large or unused variables\nCleaning up intermediate processing variables from results\nPreparing data for export by excluding internal variables","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Notes:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Non-existent variables are silently ignored\nThe function operates on all nodes in the tree simultaneously\nThe original tree is not modified; a new tree is returned","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"````","category":"page"},{"location":"quickstart/#QuickStart","page":"QuickStart","title":"QuickStart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"QuickStart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Install the latest version of CopernicusData.jl using the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt):","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"julia> ]\n(v1.10) pkg> add CopernicusData","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"The package can be updated via the package manager by","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"(v1.10) pkg> update CopernicusData","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"warn: Use Julia 1.10 or newer\n","category":"page"},{"location":"quickstart/#Open-Sentinel-3-SLSTR-Level-2-LST-product","page":"QuickStart","title":"Open Sentinel-3 SLSTR Level-2 LST product","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"using CopernicusData\nusing CairoMakie\nusing Downloads\n\nconst PRODUCT_PATH = \"https://common.s3.sbg.perf.cloud.ovh.net/eoproducts\"\nconst SLSLST=\"S03SLSLST_20191227T124111_0179_A109_T883.zarr.zip\"\n\nslstr_path = joinpath(PRODUCT_PATH, SLSLST)\nlocal_path = joinpath(tempdir(),SLSLST)\nDownloads.download(slstr_path, local_path)\n\nyaxt = open_datatree(local_path)\nyaxt","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"lat=yaxt.measurements.latitude.data\nlon=yaxt.measurements.longitude.data\nlst=yaxt.measurements.lst.data\nmin,max = minimum(skipmissing(lst)), maximum(skipmissing(lst))\nval=replace(lst, missing => 0.0)\n\nstep=2 # hide\nlon=lon[1:step:end,1:step:end] # hide\nlat=lat[1:step:end,1:step:end] # hide\nval=val[1:step:end,1:step:end] # hide\n\nfig=Figure(size=(800,600))\nax1=Axis(fig[1, 1], title=yaxt.measurements.lst.properties[\"long_name\"],\n     xlabel=\"Longitude\", ylabel=\"Latitude\")\ns=surface!(ax1,lon, lat, zeros(size(lon));\n     color=val,colorrange=(min,max),colormap=:rainbow, shading=NoShading)\n     Colorbar(fig[1, 2], s)\nfig","category":"page"},{"location":"examples/#Sentinel-3-zarr-products","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"","category":"section"},{"location":"examples/#OLCI-Level-1","page":"Sentinel-3 zarr products","title":"OLCI Level-1","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"olci_path = joinpath(PRODUCT_PATH, OLCEFR) # hide\nolci_path # hide","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"local_path = joinpath(tempdir(),OLCEFR)\nDownloads.download(olci_path, local_path)\nefr = open_datatree(local_path)\nefr","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"The product is represented by a hierarchical tree structure YAXTrees.YAXTree","category":"page"},{"location":"examples/#Opening-measurements-data","page":"Sentinel-3 zarr products","title":"Opening measurements data","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"rad = efr.measurements.oa01_radiance\nrad","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"The nodes of the YAXTree are YAXArrays.YAXArray or YAXArrays.Dataset","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"rad.data","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"The underlying data is a CFDiskArray","category":"page"},{"location":"examples/#Plot-data","page":"Sentinel-3 zarr products","title":"Plot data","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"We use Makie.jl to plot the data.","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"lat=efr.measurements.latitude.data\nlon=efr.measurements.longitude.data\nval=replace(rad.data, missing => 0.0)\n\nstep=10 # hide\nlon=lon[1:step:end,1:step:end] # hide\nlat=lat[1:step:end,1:step:end] # hide\nval=val[1:step:end,1:step:end] # hide\nmin,max = minimum(val), maximum(val)\n\nfig=Figure(size=(1200,600))\nax1=Axis(fig[1, 1], title=rad.properties[\"long_name\"],\n     xlabel=\"Longitude\", ylabel=\"Latitude\")\ns=surface!(ax1,lon, lat, zeros(size(lon));\n     color=val,colorrange=(min,max),colormap=:rainbow, shading=NoShading)\n     Colorbar(fig[1, 2], s)\nax2=Axis(fig[1, 3], title=rad.properties[\"long_name\"],\n     xlabel=\"Columns\", ylabel=\"Rows\")\nheatmap!(ax2, val, colormap=:rainbow, colorrange=(min,max))\nfig","category":"page"},{"location":"examples/#Open-meteorological-conditions","page":"Sentinel-3 zarr products","title":"Open meteorological conditions","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"meteo = efr.conditions.meteorology","category":"page"},{"location":"examples/#Interpolate-the-atmospheric-temperature-at-p832.2-hPa","page":"Sentinel-3 zarr products","title":"Interpolate the atmospheric temperature at p=832.2 hPa","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"tp = linear_interpolation(meteo, \"atmospheric_temperature_profile\", dims=\"pressure_level\", value=832.2)\nfig=Figure(size=(800,600))\nax=Axis(fig[1, 1], title=\"atmospheric_temperature_profile @ 832.2 hPa\",\n     xlabel=\"tp_columns\", ylabel=\"tp_rows\")\nheatmap!(ax,tp.data)\nfig","category":"page"},{"location":"examples/#SLSTR-Level-2-FRP","page":"Sentinel-3 zarr products","title":"SLSTR Level-2 FRP","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"frp_path = joinpath(PRODUCT_PATH, SLSFRP) # hide\nfrp_path # hide","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"local_path = joinpath(tempdir(),SLSFRP)\nDownloads.download(frp_path, local_path)\nfrp = open_datatree(local_path)\nfrp","category":"page"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"The product is represented by a hierarchical tree structure YAXTrees.YAXTree","category":"page"},{"location":"examples/#Opening-measurements-data-(1D)","page":"Sentinel-3 zarr products","title":"Opening measurements data (1D)","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"meas = frp.measurements.inadir\nmeas","category":"page"},{"location":"examples/#Plot-Active-Fire-Pixel-on-a-Plate-Carrée-grid","page":"Sentinel-3 zarr products","title":"Plot Active Fire Pixel on a Plate-Carrée grid","text":"","category":"section"},{"location":"examples/","page":"Sentinel-3 zarr products","title":"Sentinel-3 zarr products","text":"using CairoMakie, GeoMakie\n\nfrp_vals = Int64.(round.(frp.measurements.inadir.frp_mwir.data))\nfig = Figure(size=(800,600))\nax = GeoAxis(fig[1,1]; dest = \"+proj=merc\")\nGeoMakie.xlims!(ax, -125, -114)\nGeoMakie.ylims!(ax, 40, 50)\nlines!(ax, GeoMakie.coastlines(50), color=:black)\ns=GeoMakie.scatter!(ax, \n    frp.measurements.inadir.longitude.data,\n    frp.measurements.inadir.latitude.data,\n    color=frp_vals,\n    colormap=:thermal,\n    markersize=15,\n    colorrange=(0, 100),\n    )\nColorbar(fig[1,2],s, ticks=0:20:100)\nfig","category":"page"},{"location":"#CopernicusData.jl","page":"Home","title":"CopernicusData.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CopernicusData.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"CopernicusData is a framework to be used for Earth Observation satellite data processing from the EU Copernicus program, especially the Sentinels Missions. It defines a data structure for managing, storing EO data and a light orchestration framework to implement and chain processing steps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# lst_data = reverse(permutedims(tree.measurements.lst.data),dims=1) # hide\nlst_data = reverse(tree.measurements.lst.data,dims=2) # hide\n# heatmap(lst_data, title=\"Land Surface Temperature over Brazil (Sentinel-3 A)\", c=:rainbow, xlabel=\"columns\", ylabel=\"rows\") # hide\nfig=Figure(size=(800,600)) # hide\nax=Axis(fig[1, 1], title=\"Land Surface Temperature over Brazil (Sentinel-3 A)\", # hide\n     xlabel=\"columns\", ylabel=\"rows\") # hide\nheatmap!(ax,lst_data, colormap=:rainbow) # hide\nfig # hide","category":"page"},{"location":"#The-Data-structure","page":"Home","title":"The Data structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The data structure used in CopernicusData.jl is mostly focused on zarr format,  using Zarr.jl package. The data representation is based on YAXArrays.jl. Though it is designed to handle the Sentinels new EOPF product format, it remains fully generic and can represent any kind of hierarchical data tree structure. Please visit https://eopf.copernicus.eu/eopf/ to have further details about the EOPF data format.","category":"page"},{"location":"#YAXTrees-module","page":"Home","title":"YAXTrees module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The YAXTrees module provide a hierarchical tree structure of YAXArrays or Datasets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below is a basic usage to construct a tree structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"root = YAXTree()\nroot.childA = YAXTree(\"childA\")\nroot.childB = YAXTree(\"childB\")\nroot.childA.grandchild = YAXTree(\"grandchild\")\nroot","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using Zarr backend, a recursive zarr structure representing Copernicus product can be accessed with the open_datatree function. Using the feature from YAXArrays.jl, based on DiskArrays.jl, the data is lazy loaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tree = open_datatree(local_path)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more detailed view can be displayed","category":"page"},{"location":"","page":"Home","title":"Home","text":"YAXTrees.show_tree(tree; details=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can use dictionary or the traditional dot indexing to access any node of the tree structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"tree[\"measurements\"].data","category":"page"},{"location":"","page":"Home","title":"Home","text":"tree.conditions.geometry.solar_zenith_tn","category":"page"},{"location":"#EOProduct-module","page":"Home","title":"EOProduct module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"***deprecated*** ","category":"page"},{"location":"#Orchestration","page":"Home","title":"Orchestration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A light orchestration is providing by the ̀EOTriggering module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"utils.jl\") # hide\ninclude_toml_in_markdown(\"../resources/payload.toml\") #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"payload_file_path=\"../resources/payload.toml\"\nEOTriggering.run(payload_file_path)","category":"page"},{"location":"lst/#LST-processor","page":"LST processor","title":"LST processor","text":"","category":"section"}]
}
